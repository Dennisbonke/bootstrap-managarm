From d8fc7a90085b141b73d128e1ebd582687445128e Mon Sep 17 00:00:00 2001
From: Dennis Bonke <admin@dennisbonke.com>
Date: Wed, 2 Aug 2023 05:02:00 +0200
Subject: [PATCH 4/5] managarm: More additions for a newer nix version

Signed-off-by: Dennis Bonke <admin@dennisbonke.com>
---
 src/unix/mlibc/mod.rs | 190 ++++++++++++++++++++++++++++++++++++++----
 1 file changed, 174 insertions(+), 16 deletions(-)

diff --git a/src/unix/mlibc/mod.rs b/src/unix/mlibc/mod.rs
index 1787268..db952e6 100644
--- a/src/unix/mlibc/mod.rs
+++ b/src/unix/mlibc/mod.rs
@@ -8,8 +8,22 @@ pub type c_ulong = u64;
 pub type wchar_t = ::c_int;
 
 // options/posix/include/sys/resource.h
+pub const RLIMIT_CORE: ::c_int = 1;
+pub const RLIMIT_CPU: ::c_int = 2;
+pub const RLIMIT_DATA: ::c_int = 3;
+pub const RLIMIT_FSIZE: ::c_int = 4;
+pub const RLIMIT_NOFILE: ::c_int = 5;
+pub const RLIMIT_STACK: ::c_int = 6;
+pub const RLIMIT_AS: ::c_int = 7;
 pub type rlim_t = ::c_ulong;
 
+s! {
+    pub struct rlimit {
+        pub rlim_cur: rlim_t,
+        pub rlim_max: rlim_t,
+    }
+}
+
 // abis/mlibc/mode_t.h
 pub type mode_t = ::c_int;
 
@@ -21,6 +35,7 @@ pub type off_t = ::c_long;
 
 // abis/mlibc/vm-flags.h
 pub const MAP_ANON: ::c_int = 8;
+pub const MAP_ANONYMOUS: ::c_int = MAP_ANON;
 pub const MAP_PRIVATE: ::c_int = 1;
 pub const MAP_SHARED: ::c_int = 2;
 pub const PROT_EXEC: ::c_int = 4;
@@ -46,8 +61,11 @@ pub const MCL_CURRENT: ::c_int = 1;
 pub const MCL_FUTURE: ::c_int = 2;
 
 // options/ansi/include/time.h
-pub const CLOCK_MONOTONIC: clockid_t = 1;
 pub const CLOCK_REALTIME: clockid_t = 0;
+pub const CLOCK_MONOTONIC: clockid_t = 1;
+pub const CLOCK_BOOTTIME: clockid_t = 7;
+pub const CLOCK_REALTIME_ALARM: clockid_t = 8;
+pub const CLOCK_BOOTTIME_ALARM: clockid_t = 9;
 pub type clock_t = ::c_ulong;
 s! {
     pub struct tm {
@@ -63,6 +81,11 @@ s! {
         pub tm_gmtoff: ::c_long,
         pub tm_zone: *const ::c_char,
     }
+
+    pub struct itimerspec {
+        pub it_interval: ::timespec,
+        pub it_value: ::timespec,
+    }
 }
 
 // options/ansi/include/bits/ansi/clockid_t.h
@@ -83,11 +106,16 @@ pub type fsblkcnt_t = ::c_uint;
 // options/posix/include/bits/posix/fsfilcnt_t.h
 pub type fsfilcnt_t = ::c_uint;
 
-// abis/mlibc/signal.h
+// options/linux/include/sys/timerfd.h
+pub const TFD_TIMER_ABSTIME: ::c_int = 1;
+pub const TFD_NONBLOCK: ::c_int = O_NONBLOCK;
+pub const TFD_CLOEXEC: ::c_int = O_CLOEXEC;
+
+// abis/linux/signal.h
 pub const SIGABRT: ::c_int = 6;
 pub const SIGALRM: ::c_int = 14;
 pub const SIGBUS: ::c_int = 7;
-pub const SIGCANCEL: ::c_int = 34;
+pub const SIGCANCEL: ::c_int = 32;
 pub const SIGCHLD: ::c_int = 17;
 pub const SIGCONT: ::c_int = 18;
 pub const SIGFPE: ::c_int = 8;
@@ -101,8 +129,8 @@ pub const SIGPOLL: ::c_int = SIGIO;
 pub const SIGPROF: ::c_int = 27;
 pub const SIGPWR: ::c_int = 30;
 pub const SIGQUIT: ::c_int = 3;
-pub const SIGRTMAX: ::c_int = 33;
-pub const SIGRTMIN: ::c_int = 32;
+pub const SIGRTMAX: ::c_int = 64;
+pub const SIGRTMIN: ::c_int = 35;
 pub const SIGSEGV: ::c_int = 11;
 pub const SIGSTKFLT: ::c_int = 16;
 pub const SIGSTOP: ::c_int = 19;
@@ -119,17 +147,22 @@ pub const SIGVTALRM: ::c_int = 26;
 pub const SIGWINCH: ::c_int = 28;
 pub const SIGXCPU: ::c_int = 24;
 pub const SIGXFSZ: ::c_int = 25;
-pub const SIG_SETMASK: ::c_int = 3;
-pub const SIG_UNBLOCK: ::c_int = 2;
-
-
-pub const SA_NOCLDSTOP: ::c_int = 1 << 0;
-pub const SA_ONSTACK: ::c_int = 1 << 1;
-pub const SA_RESETHAND: ::c_int = 1 << 2;
-pub const SA_RESTART: ::c_int = 1 << 3;
-pub const SA_SIGINFO: ::c_int = 1 << 4;
-pub const SA_NOCLDWAIT: ::c_int = 1 << 5;
-pub const SA_NODEFER: ::c_int = 1 << 6;
+pub const SIG_BLOCK: ::c_int = 0;
+pub const SIG_UNBLOCK: ::c_int = 1;
+pub const SIG_SETMASK: ::c_int = 2;
+
+pub const SA_NOCLDSTOP: ::c_int = 1;
+pub const SA_NOCLDWAIT: ::c_int = 2;
+pub const SA_SIGINFO: ::c_int = 4;
+pub const SA_ONSTACK: ::c_int = 0x08000000;
+pub const SA_RESTART: ::c_int = 0x10000000;
+pub const SA_NODEFER: ::c_int = 0x40000000;
+pub const SA_RESETHAND: ::c_int = 0x80000000;
+pub const SA_RESTORER: ::c_int = 0x04000000;
+
+pub const SIGEV_SIGNAL: ::c_int = 0;
+pub const SIGEV_NONE: ::c_int = 1;
+pub const SIGEV_THREAD: ::c_int = 2;
 
 pub type sigset_t = ::c_long;
 s! {
@@ -154,6 +187,20 @@ s! {
     pub struct sigval {
         pub sival_ptr: *mut ::c_void,
     }
+
+    pub struct sigevent {
+        pub sigev_value: ::sigval,
+        pub sigev_notify: ::c_int,
+        pub sigev_signo: ::c_int,
+        pub sigev_notify_function: fn(sigval) -> *mut ::c_void,
+        // Actually a union.  We only expose sigev_notify_thread_id because it's
+        // the most useful member
+        // pub sigev_notify_thread_id: ::c_int,
+        // #[cfg(target_pointer_width = "64")]
+        // __unused1: [::c_int; 11],
+        // #[cfg(target_pointer_width = "32")]
+        // __unused1: [::c_int; 12]
+    }
 }
 
 // abis/mlibc/termios.h
@@ -289,6 +336,9 @@ pub type in_addr_t = u32;
 // options/posix/include/bits/posix/in_port_t.h
 pub type in_port_t = u16;
 
+// options/posix/include/bits/posix/timer_t.h
+pub type timer_t = *mut ::c_void;
+
 // options/ansi/include/stdlib.h
 pub const EXIT_FAILURE: ::c_int = 1;
 pub const EXIT_SUCCESS: ::c_int = 0;
@@ -389,6 +439,7 @@ pub const SO_TYPE: ::c_int = 16;
 pub const TCP_KEEPCNT: ::c_int = 6;
 pub const TCP_KEEPIDLE: ::c_int = 4;
 pub const TCP_KEEPINTVL: ::c_int = 5;
+pub const MSG_NOSIGNAL: ::c_int = 0x10;
 
 pub type sa_family_t = ::c_int;
 s! {
@@ -427,6 +478,36 @@ f! {
     pub fn CMSG_SPACE(_len: ::c_uint) -> ::c_uint {
         core::unimplemented!()
     }
+
+    pub fn FD_CLR(_fd: ::c_int, _set: *mut fd_set) -> () {
+        core::unimplemented!()
+        // let fd = fd as usize;
+        // let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        // (*set).fds_bits[fd / size] &= !(1 << (fd % size));
+        // return
+    }
+
+    pub fn FD_ISSET(_fd: ::c_int, _set: *const fd_set) -> bool {
+        core::unimplemented!()
+        // let fd = fd as usize;
+        // let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        // return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0
+    }
+
+    pub fn FD_SET(_fd: ::c_int, _set: *mut fd_set) -> () {
+        core::unimplemented!()
+        // let fd = fd as usize;
+        // let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;
+        // (*set).fds_bits[fd / size] |= 1 << (fd % size);
+        // return
+    }
+
+    pub fn FD_ZERO(_set: *mut fd_set) -> () {
+        core::unimplemented!()
+        // for slot in (*set).fds_bits.iter_mut() {
+        //     *slot = 0;
+        // }
+    }
 }
 
 // abis/mlibc/errno.h
@@ -473,6 +554,7 @@ pub const ETXTBSY: ::c_int = 1073;
 pub const EWOULDBLOCK: ::c_int = EAGAIN;
 pub const EXDEV: ::c_int = 1075;
 pub const EPROTO: ::c_int = 1065;
+pub const ENOTSUP: ::c_int = 1057;
 
 // options/posix/include/fcntl.h
 pub const AT_FDCWD: ::c_int = -100;
@@ -527,6 +609,18 @@ pub const SEEK_SET: ::c_int = 3;
 
 // options/posix/include/netinet/tcp.h
 pub const TCP_NODELAY: ::c_int = 1;
+pub const TCP_MAXSEG: ::c_int = 2;
+
+// options/posix/include/net/if.h
+pub const IFF_UP: ::c_int = 0x1;
+pub const IFF_BROADCAST: ::c_int = 0x2;
+pub const IFF_DEBUG: ::c_int = 0x4;
+pub const IFF_LOOPBACK: ::c_int = 0x8;
+pub const IFF_POINTOPOINT: ::c_int = 0x10;
+pub const IFF_NOARP: ::c_int = 0x80;
+pub const IFF_PROMISC: ::c_int = 0x100;
+pub const IFF_ALLMULTI: ::c_int = 0x200;
+pub const IFF_MULTICAST: ::c_int = 0x1000;
 
 // options/posix/include/bits/posix/stat.h
 pub const UTIME_OMIT: c_long = 1073741822;
@@ -608,6 +702,12 @@ pub const POLLHUP: ::c_short = 8;
 pub const POLLIN: ::c_short = 1;
 pub const POLLNVAL: ::c_short = 0x40;
 pub const POLLOUT: ::c_short = 2;
+pub const POLLPRI: ::c_short = 0x04;
+pub const POLLWRNORM: ::c_short = 0x80;
+pub const POLLRDNORM: ::c_short = 0x100;
+pub const POLLWRBAND: ::c_short = 0x200;
+pub const POLLRDBAND: ::c_short = 0x400;
+pub const POLLERR: ::c_short = 0x10;
 pub type nfds_t = ::size_t;
 
 // options/linux/include/sys/epoll.h
@@ -629,6 +729,7 @@ pub const EPOLL_CLOEXEC: ::c_int = 1;
 pub const EPOLL_CTL_ADD: ::c_int = 1;
 pub const EPOLL_CTL_DEL: ::c_int = 2;
 pub const EPOLL_CTL_MOD: ::c_int = 3;
+pub const EPOLLEXCLUSIVE: ::c_int = 1 << 28;
 
 s! {
     pub struct epoll_event {
@@ -708,6 +809,21 @@ s! {
     }
 }
 
+// options/posix/include/sys/select.h
+pub const FD_SETSIZE: usize = 1024;
+
+// abis/linux/utsname.h
+s! {
+    pub struct utsname {
+        pub sysname: [::c_char; 65],
+        pub nodename: [::c_char; 65],
+        pub release: [::c_char; 65],
+        pub version: [::c_char; 65],
+        pub machine: [::c_char; 65],
+        pub domainname: [::c_char; 65]
+    }
+}
+
 // options/linux-headers/include/linux/if_packet.h
 s! {
     pub struct sockaddr_ll {
@@ -1029,4 +1145,46 @@ extern "C" {
         flag: ::c_int,
     ) -> ::c_int;
     pub fn writev(fd: ::c_int, iov: *const ::iovec, count: ::c_int) -> ::ssize_t;
+    pub fn mknodat(
+        dirfd: ::c_int,
+        pathname: *const ::c_char,
+        mode: ::mode_t,
+        dev: dev_t,
+    ) -> ::c_int;
+    pub fn preadv(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn pwritev(
+        fd: ::c_int,
+        iov: *const ::iovec,
+        iovcnt: ::c_int,
+        offset: ::off_t,
+    ) -> ::ssize_t;
+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;
+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;
+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;
+    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;
+    pub fn uname(buf: *mut ::utsname) -> ::c_int;
+    pub fn timerfd_create(clockid: ::c_int, flags: ::c_int) -> ::c_int;
+    pub fn timerfd_settime(
+        fd: ::c_int,
+        flags: ::c_int,
+        new_value: *const itimerspec,
+        old_value: *mut itimerspec,
+    ) -> ::c_int;
+    pub fn timerfd_gettime(fd: ::c_int, curr_value: *mut itimerspec) -> ::c_int;
+    pub fn timer_create(clock_id: clockid_t, evp: *mut sigevent, timerid: *mut timer_t) -> ::c_int;
+    pub fn timer_settime(
+        timerid: ::timer_t,
+        flags: ::c_int,
+        new_value: *const ::itimerspec,
+        old_value: *mut ::itimerspec,
+    ) -> ::c_int;
+    pub fn timer_gettime(timerid: ::timer_t, curr_value: *mut ::itimerspec) -> ::c_int;
+    pub fn timer_getoverrun(timerid: ::timer_t) -> ::c_int;
+    pub fn timer_delete(timerid: ::timer_t) -> ::c_int;
+    pub fn clock_getres(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;
 }
-- 
2.40.1

